#include "tb_driver.h"
#include <iomanip>
#include <fstream>
void tb_driver::generate_reset(void){
     //генерация ресета
    rst.write(1);
    wait(clk->posedge_event());//next_trigger();
    rst.write(0);
    wait(clk->posedge_event());//next_trigger();
};

void tb_driver::generate_biases(void) {
    if(biases_generated1 == sc_logic(0)){ 
        for (int i=0; i<BIASES; i++){
            biases_flattened[i]=C[i];
        } 
        biases.write(0);
        biases_vld.write(0);
        for (int i=0;i<BIASES;i++){
            biases_vld.write(1);
            biases_tmp=biases_flattened[i];
            biases.write(biases_tmp);
            do{
                wait(clk->posedge_event());
//                next_trigger();
            }while(!biases_rdy.read());
            biases_vld.write(0);
        }
        biases.write(0);
        biases_generated1 = sc_logic(1);
    }
    else{
        wait(clk->posedge_event());
//        next_trigger();
    }
};

void tb_driver::generate_kernel(void) {
        
    //это входные матрицы кернела, баесов и изображения
    //нормализация кернела- деление каждого элемента кернела на сумму его элементов
    
    double A[N1][M1][L1] = {-0.1334408223628997802734375, -0.0087087247520685195922852, -0.0744715556502342224121094, 0.1103126406669616699218750, 0.1013357564806938171386719, 0.1156024709343910217285156, 0.2459016889333724975585938, 0.1823249459266662597656250, 0.0949456691741943359375000, 0.1053847372531890869140625, -0.0560020990669727325439453, -0.0506454147398471832275391, 0.0832245573401451110839844, 0.0698637589812278747558594, -0.1485281288623809814453125, 0.0766758918762207031250000, 0.2105543017387390136718750, 0.0994880497455596923828125, 0.1755441576242446899414062, -0.0025231766048818826675415, -0.1734967529773712158203125, 0.0727402716875076293945312, 0.1283628940582275390625000, 0.2471047788858413696289062, -0.1501168608665466308593750, 0.0968883559107780456542969, 0.0136624425649642944335938, -0.2835018038749694824218750, 0.1345463097095489501953125, -0.3537354171276092529296875, 0.0061263376846909523010254, -0.0839346870779991149902344, -0.0864856466650962829589844, 0.0884167775511741638183594, -0.0300364848226308822631836, 0.1984982192516326904296875, -0.0505895279347896575927734, 0.1692831367254257202148438, 0.1869760602712631225585938, 0.2136799395084381103515625, 0.1563679277896881103515625, 0.0563280731439590454101562, -0.1734506636857986450195312, 0.1702887117862701416015625, -0.2340481728315353393554688, 0.0095564275979995727539062, -0.0633049905300140380859375, 0.0425814501941204071044922, -0.1470266282558441162109375, -0.0638984590768814086914062, 0.1256543993949890136718750, -0.2009634375572204589843750, -0.0125859212130308151245117, 0.0627527013421058654785156, 0.1806637793779373168945312, 0.2293261438608169555664062, 0.1556869894266128540039062, -0.2128604203462600708007812, -0.0089199570938944816589355, -0.0540362335741519927978516, 0.1379627734422683715820312, -0.1180670559406280517578125, 0.1117793992161750793457031, 0.1088332608342170715332031, -0.1136551201343536376953125, -0.0019576887134462594985962, -0.0708144158124923706054688, 0.1699092090129852294921875, -0.0867050141096115112304688, 0.2585493326187133789062500, -0.1310384571552276611328125, 0.0657599940896034240722656, 0.1818284690380096435546875, 0.0501676760613918304443359, 0.1352173388004302978515625, -0.0462655685842037200927734, -0.2438277900218963623046875, -0.1349650919437408447265625, 0.2280425727367401123046875, -0.0638374462723731994628906, -0.3344029188156127929687500, 0.1380349248647689819335938, 0.1345756798982620239257812, -0.0862676128745079040527344, 0.0740810707211494445800781, 0.1040261685848236083984375, 0.1143994554877281188964844, 0.2250242978334426879882812, 0.0832367986440658569335938, -0.1197310537099838256835938, 0.0474462211132049560546875, 0.2156127393245697021484375, -0.1272477805614471435546875, -0.0256480854004621505737305, -0.1320263296365737915039062, -0.1766695082187652587890625, -0.1392686367034912109375000, 0.1201948970556259155273438, -0.1670113056898117065429688, 0.0334975942969322204589844, 0.2410885095596313476562500, -0.1317615211009979248046875, -0.0832119286060333251953125, 0.1086513772606849670410156, 0.1315574347972869873046875, 0.2232054024934768676757812, -0.0371293351054191589355469, 0.1672631055116653442382812, 0.0272265840321779251098633, 0.2284591495990753173828125, -0.1870962232351303100585938, 0.1323637217283248901367188, 0.1573654711246490478515625, -0.1221243813633918762207031, -0.1680716723203659057617188, -0.0219023935496807098388672, 0.1997896283864974975585938, 0.1659678071737289428710938, -0.0458473898470401763916016, 0.0717002078890800476074219, -0.1625258326530456542968750, 0.1371255666017532348632812, 0.0277941972017288208007812, -0.1740090399980545043945312, -0.0082714920863509178161621, -0.1457158923149108886718750, -0.0556254386901855468750000, 0.0418825186789035797119141, -0.1083627939224243164062500, 0.2751140296459197998046875, -0.0904558151960372924804688, 0.0466368943452835083007812, 0.2524847388267517089843750, -0.1006272137165069580078125, 0.0381098985671997070312500, 0.0850499570369720458984375, 0.0484856404364109039306641, -0.0684833824634552001953125, -0.0808828026056289672851562, 0.0083666918799281120300293, 0.0753766596317291259765625, 0.1253672242164611816406250, -0.0310533326119184494018555, 0.0881438478827476501464844, 0.0382105596363544464111328, -0.0659709945321083068847656, 0.1293583810329437255859375, -0.0140871778130531311035156, 0.0868493393063545227050781, 0.2041825205087661743164062, -0.0669835507869720458984375, 0.1141782477498054504394531, 0.0055147563107311725616455, 0.1471459865570068359375000, 0.1341662257909774780273438, 0.0455632321536540985107422, 0.1397219300270080566406250, 0.0188694298267364501953125, -0.0621911995112895965576172, 0.0197435840964317321777344, 0.2401071935892105102539062, 0.2042565494775772094726562, -0.1405453681945800781250000, -0.1381194740533828735351562, -0.0405460074543952941894531, 0.1361885368824005126953125, -0.1887856870889663696289062, 0.0442086495459079742431641, -0.0574250929057598114013672, -0.2391771823167800903320312, 0.2915632128715515136718750, -0.0724466890096664428710938, 0.1313868612051010131835938, -0.1772097796201705932617188, 0.1818936765193939208984375, -0.1648586988449096679687500, 0.0427887514233589172363281, 0.2589043974876403808593750, 0.1560312807559967041015625, 0.1540612131357192993164062, 0.2514920532703399658203125, 0.1767254918813705444335938, 0.0653855055570602416992188, -0.0656551346182823181152344, 0.1775472164154052734375000, 0.1620117127895355224609375, 0.2654829919338226318359375, 0.1958227753639221191406250, 0.0742204934358596801757812, 0.1669477671384811401367188, 0.1021381914615631103515625, 0.2609765529632568359375000, 0.1300974339246749877929688, -0.0464182496070861816406250, 0.2235770523548126220703125, 0.0571969188749790191650391, 0.1847932338714599609375000, -0.3176175653934478759765625, -0.0458432845771312713623047, -0.0107199260964989662170410, -0.0945426300168037414550781, 0.1813056766986846923828125, 0.1111211404204368591308594, 0.0986972153186798095703125, 0.2304167896509170532226562, 0.2316483557224273681640625, -0.1053984835743904113769531, 0.2507510781288146972656250, 0.0828195512294769287109375, -0.0198040548712015151977539, -0.3174853324890136718750000, 0.0530890822410583496093750, 0.1092780008912086486816406, -0.0136705935001373291015625, 0.0859541594982147216796875, -0.0466487482190132141113281, -0.2115994095802307128906250, 0.1998959332704544067382812, -0.0355514921247959136962891, -0.0056355684064328670501709, -0.0327090099453926086425781, 0.0012764279963448643684387, 0.1376881301403045654296875, -0.1973469704389572143554688, 0.2088107764720916748046875, -0.1375161707401275634765625, 0.0767594873905181884765625, -0.1475086510181427001953125, 0.2070971727371215820312500, 0.0296136345714330673217773, 0.1692061424255371093750000, 0.0033886176533997058868408, -0.2048237323760986328125000, 0.1469190269708633422851562, -0.0866658762097358703613281, -0.0888174623250961303710938, 0.2598103880882263183593750, 0.2260870188474655151367188, 0.1089378595352172851562500, 0.0689459145069122314453125, 0.2336969077587127685546875, 0.1502571254968643188476562, -0.1687576025724411010742188, 0.1031824275851249694824219, -0.0249132011085748672485352, -0.1596026569604873657226562, 0.1020670831203460693359375, -0.1817942112684249877929688, -0.0568647831678390502929688, 0.2381323426961898803710938, 0.1547280102968215942382812, 0.0781389921903610229492188, 0.1212623715400695800781250, 0.2253460735082626342773438, 0.2501133084297180175781250, 0.0327958203852176666259766, 0.1188950911164283752441406, -0.0708352476358413696289062, 0.1387028098106384277343750, -0.1358170807361602783203125, 0.0005758021143265068531036, 0.0743186399340629577636719, 0.1525160372257232666015625, -0.0413832068443298339843750, -0.2427499592304229736328125, -0.1222589761018753051757812, 0.2167771309614181518554688, -0.1645785570144653320312500, 0.1734100282192230224609375, 0.0284365471452474594116211, 0.0312003307044506072998047, 0.0282942708581686019897461, 0.0233102776110172271728516, 0.2675340771675109863281250, 0.1333180367946624755859375, 0.3178539276123046875000000, -0.0447467491030693054199219, 0.0765110552310943603515625, -0.1525852978229522705078125, -0.1764259785413742065429688, 0.1710466146469116210937500, -0.0698607563972473144531250, -0.1001522541046142578125000, 0.0878010615706443786621094, 0.1599699407815933227539062, 0.1762448251247406005859375, 0.1587602794170379638671875, 0.2837161719799041748046875 };
    double kernel_flattened[KER];

     for (int j = 0; j < N1; ++j) {
         for (int i = 0; i < M1; ++i) {
            for (int k = 0; k < L1; ++k) {
                    kernel_flattened[j * M1 * L1 + i * L1 + k]=A[j][i][k];
            }
         }
     }
/**/
    std::fstream file( kernelfile, std::fstream::in);
    if (!file){
        cout<<"Файл " << kernelfile << " не найден\n";
    }
    for (int i = 0; i < KER; i++){
        file >> kernel_flattened[i];
        
    }
    /*
      for (int i = 0; i < KER; i++){
        cout << kernel2_flattened[i] << ' ';
        
    } /**/
    file.close(); 
 
    kernel.write(0);
    kernel_vld.write(0);

    //поэлементная передача данных на порты
     double kernel_tmp;
     for (int i=0; i<KER; i++){
         kernel_vld.write(1);
         kernel_tmp=kernel_flattened[i];
         kernel.write(kernel_tmp);
         do{
             wait(clk->posedge_event());
        }while(!kernel_rdy.read());
        kernel_vld.write(0);
     }
     kernel.write(0);
};


void tb_driver::generate_image(void){
    double image_flattened[IMG];
    for (int i = 0; i < M2; ++i) {
            for (int k = 0; k < N2; ++k) {
                image_flattened[ i * N2 + k]=B[i][k];
               // cout<<B[i][k]<<" ";
            }
            //cout<<endl;
    }
    /*
    std::fstream file( imagefile, std::fstream::in);
    if (!file){
        cout<<"Файл " << imagefile << " не найден\n";
    }
    for (int i = 0; i < IMG; i++){
        file >> image_flattened[i];
        
    }
    file.close();
      cout<<"------------image_flattened-----------"<<endl;
    for (int i=0;i<IMG;i++){
        cout<< image_flattened[IMG]<< " \n";
    } 
    /* */
    //поэлементная передача данных на порты
    image.write(0);
    image_vld.write(0);
     double image_tmp;
     for (int i=0; i<IMG; i++){
         image_vld.write(1);
         image_tmp=image_flattened[i];
         
         image.write(image_tmp);
         do{
             wait(clk->posedge_event());
        }while(!image_rdy.read());
        image_vld.write(0);
     }
    image.write(0);

};

void tb_driver::conv_2d_1_sink(void){
    //создаём файл для вывода
    /*char conv_2d_1_output_file[21632];
    sprintf(conv_2d_1_output_file, " ./conv_2d_1_output_recieved.dat");
    outfp=fopen(conv_2d_1_output_file, "w");
    if (outfp == NULL){
        cout<<" Невозможно открыть conv_2d_1_output_recieved.dat для записи"<<endl;
        exit(0);
    }*/
    //инициализируем хэндшейк
    conv_2d_1_result_rdy.write(0);
    wait(clk->posedge_event());

    double conv_2d_1_result_flattened[CONV_ED];
    //double conv_2d_1_result_arr[L3][M3][N3];
    while(true){
        if (conv_2d_1_fetched == sc_logic(0)){
            for(int i=0;i<CONV_ED+1;i++){
                conv_2d_1_result_rdy.write(1);
                do{
                    wait(clk->posedge_event());
                }while (!conv_2d_1_result_vld.read());
                conv_2d_1_result_flattened[i]=conv_2d_1_result.read();
                conv_2d_1_result_rdy.write(0);
                //fprintf(outfp, "%f\n", conv_2d_1_result.read());
            }
            cout<<"@" << sc_time_stamp() <<" convolution data recieved from CONV_2D_1"<<endl;
            /* 
            for (int i=0;i<CONV_ED;i++){
                cout<<conv_2d_1_result_flattened[i]<<" ";
            } */
            
            for (int i = 0; i < N3; i++) {
                    for (int j = 0; j < M3; j++) {
                        for (int k = 0; k < L3; k++) {
                            conv_2d_1_result_arr[i][j][k]=conv_2d_1_result_flattened[i*L3*M3+j*L3+k+1]; 
                        }
                    }
            } 
            #ifdef TB_OUTPUT    
                cout<<"[отладочный вывод][DRI_TB] результат CONV_2D_1: "<<endl;
                for (int i = 0; i < N3; i++) {
                    for (int j = 0; j < M3; j++) {
                        for (int k = 0; k < L3; k++) {
                            cout<<std::fixed <<std::setprecision(25)<< conv_2d_1_result_arr[i][j][k] << "\n ";
                        }
                    }
                } 
                cout << endl << endl<< endl << endl<< endl << endl<< endl << endl<< endl << endl<< endl << endl<< endl << endl;
            #endif

            conv_2d_1_fetched = sc_logic(1);
/**/    }
        else{
            wait(clk->posedge_event());
        }
        
        //sc_stop();
    }
};

void tb_driver::generate_kernel2(void){
//передача кернелов для conv_2d_2 из файла в динамический массив kernel_flattened2
    std::fstream file( kernel2file, std::fstream::in);
    if (!file){
        cout<<"Файл " << kernel2file << " не найден\n";
    }
    for (int i = 0; i < KER2; i++){
        file >> kernel2_flattened[i];
        
    }/*
      for (int i = 0; i < KER2; i++){
        cout << kernel2_flattened[i] << ' ';
        
    } /**/
    file.close(); 

    kernel2.write(0);
    kernel2_vld.write(0);

    //поэлементная передача данных на порты
     double kernel2_tmp;
     for (int i = 0; i < KER2; i++){
         kernel2_vld.write(1);
         kernel2_tmp=kernel2_flattened[i];
         kernel2.write(kernel2_tmp);
         do{
             wait(clk->posedge_event());
        }while(!kernel2_rdy.read());
        kernel2_vld.write(0);
     }
     kernel2.write(0);
     
};

void tb_driver::generate_biases2(void){
    double E[BIASES2]={-0.0319721363484859466552734, -0.0447157993912696838378906, -0.0168587751686573028564453, -0.0115468036383390426635742, -0.0336905382573604583740234, -0.0329694636166095733642578, 0.0083970054984092712402344, -0.0143109867349267005920410, -0.0381064824759960174560547, -0.0176094137132167816162109, -0.0404341891407966613769531, -0.0157356858253479003906250, -0.0006183723453432321548462, 0.0078244302421808242797852, -0.0062869302928447723388672, -0.0172499455511569976806641, -0.0435957014560699462890625, -0.0604985617101192474365234, -0.0341236703097820281982422, 0.0326732210814952850341797, -0.0488306917250156402587891, -0.0161325540393590927124023, -0.0398999825119972229003906, 0.0104548279196023941040039, -0.0517216362059116363525391, 0.0122273089364171028137207, -0.0157566219568252563476562, -0.0344855375587940216064453, -0.0323644243180751800537109, -0.0295408815145492553710938, -0.0563105605542659759521484, -0.0530514717102050781250000, 0.0186393186450004577636719, -0.0245105251669883728027344, -0.0459587126970291137695312, -0.0044532772153615951538086, 0.0402350910007953643798828, -0.0090043898671865463256836, -0.0605863630771636962890625, 0.0222345571964979171752930, -0.0693054795265197753906250, -0.0273299645632505416870117, -0.0461276248097419738769531, -0.0529682300984859466552734, -0.0445274785161018371582031, 0.0169386602938175201416016, -0.0419715307652950286865234, -0.0207674168050289154052734, -0.0417286604642868041992188, -0.0607198365032672882080078, -0.0494330450892448425292969, -0.0179587528109550476074219, -0.0164895467460155487060547, -0.0572269782423973083496094, -0.0272609032690525054931641, 0.0037255007773637771606445, -0.0060905343852937221527100, -0.0228936467319726943969727, -0.0478452965617179870605469, 0.0074354270473122596740723, 0.0810477808117866516113281, -0.0312006790190935134887695, -0.0443888306617736816406250, -0.0061311814934015274047852};

    double biases2_flattened[BIASES2];    
     for (int i = 0; i < BIASES2; i++){
         biases2_flattened[i]=E[i];
     } /**/

    biases2.write(0);
    biases2_vld.write(0);
    
    double biases2_tmp;
    for (int i = 0 ;i < BIASES2;i++){
        biases2_vld.write(1);
        biases2_tmp=biases2_flattened[i];
        biases2.write(biases2_tmp);
        do{
            wait(clk->posedge_event());
        }while(!biases2_rdy.read());
        biases2_vld.write(0);
    }
    biases2.write(0);
};

void tb_driver::conv_2d_2_sink(void){
    //инициализируем хэндшейк
    conv_2d_2_result_rdy.write(0);
    //wait(clk->posedge_event());
    while(true){
        if (conv_2d_2_fetched == sc_logic(0)){
            for(int i=0;i<CONV_ED2+1;i++){
                conv_2d_2_result_rdy.write(1);
                do{
                    wait(clk->posedge_event());
                }while (!conv_2d_2_result_vld.read());
                conv_2d_2_result_flattened[i]=conv_2d_2_result.read();
                conv_2d_2_result_rdy.write(0);
                //fprintf(outfp, "%f\n", conv_2d_1_result.read());
            }
            cout<<"@" << sc_time_stamp() <<" convolution data from CONV_2D_2 recieved"<<endl;
            for (int i = 0; i < N5; i++) {
                    for (int j = 0; j < M5; j++) {
                        for (int k = 0; k < L4; k++) {
                            conv_2d_2_result_arr[i][j][k]=conv_2d_2_result_flattened[i*M5*L4+j*L4+k+1]; 
                        }
                    }
            } 
            #ifdef TB_OUTPUT 
                cout<<"[отладочный вывод][DRI_TB] результат CONV_2D_2:"<<endl;
                
                for (int i = 0; i < N5; i++) {
                    for (int j = 0; j < M5; j++) {
                            for (int k = 0; k < L4; k++) {
                            cout <<std::setprecision(25)<<std::fixed<<conv_2d_2_result_arr[i][j][k] << " ";
                        }
                        cout << endl;
                    } 
                    cout << "_________________[CONV_2D_2]" << endl;
                    cout << endl << endl;
                }
            #endif 
            conv_2d_2_fetched = sc_logic(1);
        }
        else{
            wait(clk->posedge_event());
        }
    }
};/**/

void tb_driver::max_pool_2d_1_sink(void){
    max_pool_2d_1_result_rdy.write(0);
    while(true){
        if (max_pool_2d_1_fetched == sc_logic(0)){
            for(int i = 0; i < POOL_ED; i++){
                max_pool_2d_1_result_rdy.write(1);
                do{
                    wait(clk->posedge_event());
                }while (!max_pool_2d_1_result_vld.read());
                max_pool_2d_1_result_flattened[i]=max_pool_2d_1_result.read();
            }
            cout<<"@" << sc_time_stamp() <<" data from MAX_POOL_2D_1 recieved"<<endl;
            for (int i = 0; i < POOLOUT1; i++) {
                    for (int j = 0; j < POOLOUT2; j++) {
                        for (int k = 0; k < POOLOUT3; k++) {
                            max_pool_2d_1_result_arr[i][j][k]=max_pool_2d_1_result_flattened[i*POOLOUT2*POOLOUT3+j*POOLOUT3+k+1]; 
                        }
                    }
            } 
            #ifdef TB_OUTPUT 
                cout<<"[отладочный вывод][DRI_TB] результат MAX_POOL_2D_1:"<<endl;
                for (int i = 0; i < POOLOUT1; i++) {
                    for (int j = 0; j < POOLOUT2; j++) {
                        for (int k = 0; k < POOLOUT3; k++) {
                            cout <<std::setprecision(25)<<std::fixed<< max_pool_2d_1_result_arr[i][j][k] << " ";
                        }
                        cout << endl;
                    }
                    cout << "_________________[MAX_POOL_2D_1]" << endl;
                    cout << endl << endl;
                }
            #endif 
            max_pool_2d_1_fetched == sc_logic(1);
        }
        else{
            wait(clk->posedge_event());
        }
    }
    
};/**/

void tb_driver::generate_coeff(void){
    std::fstream file( coefffile, std::fstream::in);
    if(!file){
        cout<<"Файл "<<coefffile<<" не найден\n";
    }
    for (int i = 0; i < DENSE1_COEFF; i++){
        file >> coeff_flattened[i];
    }
    /*
    cout<<"------------------------------------------------------------------"<<endl;
    for (int i = 0; i < DENSE_COEFF; i++){
        cout<<std::setprecision(10)<<std::fixed
        <<coeff_flattened[i]<<endl;
    }
    cout<<"------------------------------------------------------------------"<<endl;
    /**/
    
    file.close();
    double coeff_tmp;
    coeff.write(0);
    coeff_vld.write(0);
    for (int i = 0; i < DENSE1_COEFF; i++){
        coeff_vld.write(1);
        coeff_tmp=coeff_flattened[i];
        coeff.write(coeff_tmp);
        do{
            wait(clk->posedge_event());
        }while(!coeff_rdy.read());
        coeff_vld.write(0);
    }
    coeff.write(0);
    
};/**/

void tb_driver::generate_biases3(void){
    std::fstream file( biasesfile, std::fstream::in);
    if(!file){
        cout<<"Файл "<<biasesfile<<" не найден\n";
    }
    for (int i = 0; i < BIASES3; i++){
        file >> biases3_arr[i];
    }
    file.close();

    biases3.write(0);
    biases3_vld.write(0);
    for (int i = 0; i < BIASES3; i++){
        biases3_vld.write(1);
        biases3.write(biases3_arr[i]);
        do{
            wait(clk->posedge_event());
        }while(!biases3_rdy.read());
        biases3_vld.write(0);
    }
};

void tb_driver::dense1_sink(void){
    dense1_result_rdy.write(0);
    while(true){
        if(dense1_fetched == sc_logic(0)){
            for(int i = 0; i < DENSE1_OUT; i++){
                dense1_result_rdy.write(1);
                do{
                    wait(clk->posedge_event());
                }while (!dense1_result_vld.read());
                dense1_result_arr[i]=dense1_result.read();
                dense1_result_rdy.write(0);
            }
            cout<<"@" << sc_time_stamp() 
            <<" data from DENSE1 recieved"<<endl;
            #ifdef TB_OUTPUT
            cout<<"____________________________________"<<endl; 
            for(int i = 0; i < DENSE1_OUT; i++){
                cout<<std::setprecision(25)<<std::fixed
                <<dense1_result_arr[i]<<endl;
            }
            cout<<"____________________________________[DENSE1]"<<endl;
            #endif 
            dense1_fetched = sc_logic(1);
        }
        else{
            wait(clk->posedge_event());
        }
    }
};/**/

void tb_driver::generate_coeff2(void){
    std::fstream file2( coefffile2, std::fstream::in);
    if(!file2){
        cout<<"Файл "<<coefffile2<<" не найден\n";
    }
    for (int i = 0; i < DENSE2_COEFF; i++){
        file2 >> coeff2_flattened[i];
    }
    /*
    cout<<"------------------------------------------------------------------"<<endl;
    for (int i = 0; i < DENSE2_COEFF; i++){
        cout<<std::setprecision(10)<<std::fixed
        <<coeff2_flattened[i]<<endl;
    }
    cout<<"------------------------------------------------------------------"<<endl;
    */
   
    file2.close();
    double coeff2_tmp;
    coeff2.write(0);
    coeff2_vld.write(0);
    for (int i = 0; i < DENSE2_COEFF; i++){
        coeff2_vld.write(1);
        coeff2_tmp=coeff2_flattened[i];
        coeff2.write(coeff2_tmp);
        do{
            wait(clk->posedge_event());
        }while(!coeff2_rdy.read());
        coeff2_vld.write(0);
    }
    coeff2.write(0);
    
};

void tb_driver::generate_biases4(void){
    std::fstream file( biasesfile2, std::fstream::in);
    if(!file){
        cout<<"Файл "<<biasesfile2<<" не найден\n";
    }
    for (int i = 0; i < BIASES4; i++){
        file >> biases4_arr[i];
    }
    file.close();

    biases4.write(0);
    biases4_vld.write(0);
    for (int i = 0; i < BIASES4; i++){
        biases4_vld.write(1);
        biases4.write(biases4_arr[i]);
        do{
            wait(clk->posedge_event());
        }while(!biases4_rdy.read());
        biases4_vld.write(0);
    }
};

void tb_driver::dense2_sink(void){
    dense2_result_rdy.write(0);
    while(true){
        if(dense2_fetched == sc_logic(0)){
            for(int i = 0; i < DENSE2_OUT; i++){
                dense2_result_rdy.write(1);
                do{
                    wait(clk->posedge_event());
                }while (!dense2_result_vld.read());
                dense2_result_arr[i]=dense2_result.read();
                dense2_result_rdy.write(0);
            }
            cout<<"@" << sc_time_stamp() 
            <<" data from DENSE2 recieved"<<endl;
            #ifdef TB_OUTPUT
            cout<<"____________________________________"<<endl; 
            for(int i = 0; i < DENSE2_OUT; i++){
                cout<<std::setprecision(25)<<std::fixed
                <<dense2_result_arr[i]<<endl;
            }
            cout<<"____________________________________[DENSE2]"<<endl;
            #endif 
            dense2_fetched = sc_logic(1);
        }
        else{
            wait(clk->posedge_event());
        }
    }
};/**/

